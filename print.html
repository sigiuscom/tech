<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tech Docs</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Technical Docs for interview.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="whw/index.html"><strong aria-hidden="true">2.</strong> Что происходит когда пользователь открывает веб-страницу</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="whw/01.html"><strong aria-hidden="true">2.1.</strong> DNS</a></li><li class="chapter-item expanded "><a href="whw/02.html"><strong aria-hidden="true">2.2.</strong> Сокеты</a></li><li class="chapter-item expanded "><a href="whw/03.html"><strong aria-hidden="true">2.3.</strong> Балансировщик нагрузки</a></li><li class="chapter-item expanded "><a href="whw/04.html"><strong aria-hidden="true">2.4.</strong> TLS</a></li><li class="chapter-item expanded "><a href="whw/05.html"><strong aria-hidden="true">2.5.</strong> HTTP</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="whw_kube/index.html"><strong aria-hidden="true">3.</strong> Что происходит в Kubernetes при запуске kubectl run</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="whw_kube/00.html"><strong aria-hidden="true">3.1.</strong> Кратко</a></li><li class="chapter-item expanded "><a href="whw_kube/01.html"><strong aria-hidden="true">3.2.</strong> kubectl</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> kube-apiserver</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> etcd</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Управляющие циклы</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> kubelet</div></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Tech Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/sagolubev/sagolubev.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#translation-to-russian-some-tech-docs" id="translation-to-russian-some-tech-docs">Translation to Russian some tech docs</a></h1>
<p>Перевод на русский язык некоторой технической документации, полезно для подготовки к собеседованию.
Сделано на github pages и mdbook.</p>
<p>Так же некоторые мои заметки по технологиям.</p>
<p>Отличные flash карточки по некоторым технологиям
https://flashcards.wizardzines.com/</p>
<h1><a class="header" href="#Вольный-перевод-части-репы" id="Вольный-перевод-части-репы">Вольный перевод части репы</a></h1>
<p>What happens when... <a href="https://github.com/alex/what-happens-when">https://github.com/alex/what-happens-when</a></p>
<p>Часть перевода взял с <a href="https://habr.com/ru/company/htmlacademy/blog/254825/">https://habr.com/ru/company/htmlacademy/blog/254825/</a></p>
<h1><a class="header" href="#Определение-dns" id="Определение-dns">Определение DNS</a></h1>
<p>The Domain Name System provides a distributes database which store
&quot;resource records&quot; under domain names.
A local host can participate in the process of resolving a domain name
in a several way, the simplest is shown below:</p>
<p>Host side resolving::</p>
<p>Локальный хост                                                    | Удаленный хост
|<br />
+------------------+                          +----------+          |  +----------+
|                  | пользовательские запросы |          | запросы  |  |          |
| Пользовательская |-------------------------&gt;|          |----------|-&gt;|Удаленный |
| программа        |                          | Резолвер |          |  | сервер   |
|                  |&lt;-------------------------|          |&lt;---------|--|  имен    |
|                  | ответы пользователю      |          | ответы   |  |          |
+------------------+                          +----------+          |  +----------+
|     A             |
проверка кэша   |     | сохраненные |
V     | ответы      |
+----------+           |
|   кэш    |           |
+----------+           |</p>
<ul>
<li>
<p>Браузер проверяет наличие домена в своём кэше. Например, чтоб увидеть кэш Google Chrome следует ввести в адресной строке chrome://net-internals/#dns.</p>
</li>
<li>
<p>Если домена там нет, то браузер вызывает библиотечную функцию gethostbyname (отличается в разных ОС) для поиска нужного адреса.</p>
</li>
<li>
<p>Прежде, чем искать домен по DNS gethostbyname пытается найти нужный адрес в файле hosts (его расположение отличается в разных ОС).</p>
<ul>
<li>В Linux порядок поиска можно настроить в файле /etc/nsswitch.conf, например, поведение по умолчанию:</li>
</ul>
<pre><code class="language-ini">hosts:  files dns
</code></pre>
</li>
<li>
<p>Если домен нигде не закэширован и отсутствует в файле hosts, gethostbyname отправляет запрос к сетевому DNS-серверу. Как правило, это локальный роутер или DNS-сервер интернет-провайдера.</p>
</li>
<li>
<p>При отправке запроса к DNS-серверу будет использоваться настройка приоритета использования интерфейсов для исходящего трафика (например, файл /etc/gai.conf).</p>
</li>
<li>
<p>Если DNS-сервер находится в той же подсети, то сетевая библиотека выполняет ARP-запрос, который отправляется этому серверу.</p>
</li>
<li>
<p>Если DNS-сервер находится в другой подсети, , то сетевая библиотека выполняет ARP-запрос, который отправляется на IP-адрес шлюза по умолчанию (default gateway).</p>
</li>
<li>
<p>Если DNS-сервер не может найти IP-адрес имени хоста в кэше, он отправляет запрос резолверу, который специально настроен для получения IP-адреса любого имени хоста.</p>
<ul>
<li>Когда резолвер задействован, он сначала проверяет свой собственный кэш, но если он не может найти запись, он связывается с TLD (домен верхнего уровня), вероятно, с сервером com-зоны. Com - это домен верхнего уровня.</li>
<li>TLD содержит информацию о серверах имен конкретных имен хостов. Зная имя хоста, которое пытается идентифицировать распознаватель, он может найти IP-адреса сервера имен вместе с их именами.</li>
<li>Резолвер использует IP-адреса для запроса от серверов имен, информацию об IP-адресах, которую он ищет для своего конкретного имени хоста. В зависимости от сервера имен и какой зоны он обрабатывает, он должен найти IP хоста.</li>
<li>После того, как резолвер обнаружил соответствующий IP-адрес, он возвращается на DNS-сервер, который возвращается в браузер. Повсюду серверы кэшируют имя хоста и его IP в соответствии с ограничениями времени жизни (TTL).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Процесс-отправки-arp-запроса" id="Процесс-отправки-arp-запроса">Процесс отправки ARP-запроса</a></h2>
<p>Для того, чтобы отправить широковещательный ARP-запрос необходимо отыскать целевой IP-адрес, а также знать MAC-адрес интерфейса, который будет использоваться для отправки ARP-запроса (например, настройки из /etc/gai.conf)</p>
<p>Кэш ARP проверяется для каждого целевого IP-адреса — если адрес есть в кэше, то библиотечная функция возвращает результат: Target IP = MAC.</p>
<p>Если же записи в кэше нет:</p>
<ul>
<li>Проверяется таблица маршрутизации — это делается для того, чтобы узнать, есть ли искомый IP-адрес в какой-либо из подсетей локальной таблицы. Если он там, то запрос посылается с помощью интерфейса, связанного с этой подсетью. Если адрес в таблице не обнаружен, то используется интерфейс подсети шлюза по умолчанию.</li>
<li>Определяется MAC-адрес выбранного сетевого интерфейса.</li>
<li>Отправляется ARP-запрос (второй или канальный(data link) уровень модели OSI):</li>
</ul>
<pre><code class="language-ini">ARP-запрос:
</code></pre>
<pre><code class="language-ini">Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
</code></pre>
<p>В зависимости от того, какое «железо» расположено между компьютером и роутером (маршрутизатором):</p>
<p>Прямое соединение:</p>
<ul>
<li>Если компьютер напрямую подключён к роутеру, то это устройство отправляет ARP-ответ (ARP Reply).</li>
</ul>
<p>Между ними концентратор (Хаб):</p>
<ul>
<li>Если компьютер подключён к сетевому концентратору, то этот хаб отправляет широковещательный ARP-запрос со всех своих портов. Если роутер подключён по тому же «проводу», то отправит ARP-ответ.</li>
</ul>
<p>Между ними коммутатор (свитч):</p>
<ul>
<li>Если компьютер соединён с сетевым коммутатором, то этот свитч проверит локальную CAM/MAC-таблицу, чтобы узнать, какой порт в ней имеет нужный MAC-адрес. Если нужного адреса в таблице нет, то он заново отправит широковещательный ARP-запрос по всем портам, за исключением порта, откуда пришел запрос.</li>
<li>Если в CAM/MAC-таблице коммутатора есть нужная запись, то свитч отправит ARP-запрос на порт с искомым MAC-адресом. Если входящий MAC-адрес отличается от существующего, то свитч добавит входящий MAC-адрес отправителя в таблицу CAM/MAC, затем он отправит широковещательную рассылку ARP на все порты, кроме порта, с которого поступил запрос.</li>
<li>Если роутер «на одной линии» со свитчем, то он ответит (ARP Reply).</li>
</ul>
<pre><code class="language-ini">ARP-ответ:
</code></pre>
<pre><code class="language-ini">Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
</code></pre>
<p>Теперь у сетевой библиотеки есть MAC-адрес либо DNS-сервера либо шлюза по умолчанию, который можно использовать для разрешения доменного имени:</p>
<ul>
<li>DNS-клиент устанавливает сокет для UDP-порта 53 на DNS-сервере, используя номер порта источника выше 1023.</li>
<li>Если размер ответа слишком велик, то вместо него будет использоваться TCP.</li>
<li>Если локальный или на стороне провайдера DNS-сервер «не знает» нужный адрес, то запрашивается рекурсивный поиск, который проходит по списку вышестоящих DNS-серверов, пока не будет найдена SOA-запись, а затем возвращается результат.</li>
</ul>
<h1><a class="header" href="#Открытие-сокета" id="Открытие-сокета">Открытие сокета</a></h1>
<p>Когда браузер получает IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из URL (80 порт для HTTP, 443 для HTTPS) и осуществляет вызов функции socket системной библиотеки и запрашивает поток TCP сокета — AF_INET и SOCK_STREAM.</p>
<ul>
<li>Этот запрос сначала проходит через транспортный уровень, где собирается TCP-сегмент. В заголовок добавляется порт назначения, исходный порт выбирается из динамического пула ядра (настройка net.ipv4.ip_local_port_range в Linux).</li>
<li>Получившийся сегмент отправляется на сетевой уровень, на котором добавляется дополнительный IP-заголовок. Также включаются IP-адрес сервера назначения и адрес текущей машины — после этого пакет сформирован. Тут же происходит выбор исходящего интерфейса, будет использоваться настройка приоритета использования интерфейсов для исходящего трафика (например, файл /etc/gai.conf).</li>
<li>Пакет передаётся на канальный уровень. Добавляется заголовок кадра, включающий MAC-адрес сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера). Как и на предыдущих этапах, если ядру ничего не известно о MAC-адресе шлюза, то для его нахождения отправляется широковещательный ARP-запрос.</li>
</ul>
<p>На этой точке пакет готов к передаче через:</p>
<ul>
<li>Ethernet</li>
<li>WiFi</li>
<li>По сотовой связи</li>
</ul>
<p>В случае интернет-соединения большинства частных пользователей или небольших компаний пакет будет отправлен с компьютера, через локальную сеть, а затем через модем (MOdulator/DEModulator), который транслирует цифровые единицы и нули в аналоговый сигнал, подходящий для передачи по телефонной линии, кабелю или беспроводным телефонным соединениям. На другой стороне соединения расположен другой модем, который конвертирует аналоговый сигнал в цифровые данные и передаёт их следующему сетевому узлу, где происходит дальнейший анализ данных об отправителе и получателе.</p>
<p>В конечном итоге пакет доберётся до маршрутизатора, управляющего локальной подсетью, так же называемого шлюзом. Этот шлюз-маршрутизатор может иметь много VLAN (виртуальных локальных сетей), которые разделяет IP-подсети. В зависимости от IP и подсети, входящий фрейм данных будет приземляться на физический порт, затем заголовок Ethernet пакета (в случае <code>Ethernet</code>)
будет удален, останется IP-адрес источника, IP-адрес назначения и информация о портах. Маршрутизаторы поддерживают свою таблицу маршрутизации пакетов от входящего интерфейса к исходящему интерфейсу, этот маршрутизатор читает заголовок IP-пакета и выполняет поиск в локальной таблице маршрутизации (которая строится с использованием
статических маршрутов или с использованием динамических протоколов, таких как BGP, OSPF), чтобы найти исходящий интерфейс. Перед маршрутизацией пакета в заголовке IP из поля TTL (time to live) будет вычтена 1 (используется для предотвращения бесконечного зацикливания пакетов, пакет будет отброшен, если поле TTL достигнет нуля или если текущий маршрутизатор не имеет места в своей очереди / буферах (возможно, из-за перегрузки сети) или из-за ошибочных соединений и плохого CRC.). Помимо изменения TTL могут быть изменены другие поля, например если пакеты будут фрагментированы из-за меньшего размера MTU на исходящем интерфейсе, то маршрутизатор пошлет IP пакеты в так называемых чанках (chunks) - порции, и маршрутизатор перепишет IP-заголовки основываясь на оригинальном IP-пакете, также будут изменены контрольные суммы и т.д. Наконец, эти пакеты снова будут инкапсулированы во
фрейм Ethernet или в любой другой поддерживаемый тип, который поддерживается на интерфейсе и отправлены
следующему <code>сетевому узлу</code> для аналогичной обработки. Оттуда он продолжит движение к маршрутизаторам на пути, проходящем через различные автономные системы (ASN - это уникальный номер, назначенный поставщикам интернет-услуг для идентификации себя в Интернете и маршрутизации интернет-трафика. Протокол BGP-Border Gateway Protocol поддерживает большие таблицы маршрутизации в маршрутизаторах ISP и ретрансляции пакетов в пункт назначения), а затем, наконец, достигает сервера назначения, где он передается в стек TCP / IP на сервере для дальнейшей обработки и доставки приложениям.</p>
<p>Во время TCP-соединения происходит множество подобных запросов и ответов.</p>
<h2><a class="header" href="#Жизненный-цикл-tcp-соединения" id="Жизненный-цикл-tcp-соединения">Жизненный цикл TCP-соединения</a></h2>
<p><strong>a. Клиент выбирает номер начальной последовательности (ISN) и отправляет пакет серверу с установленным битом SYN для открытия соединения.</strong></p>
<p><strong>b. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:</strong></p>
<ul>
<li>Выбирает собственный номер начальной последовательности;</li>
<li>Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности;</li>
<li>Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения получения первого пакета.</li>
</ul>
<p><strong>c. Клиент подтверждает соединение путём отправки пакета:</strong></p>
<ul>
<li>Увеличивает номер своей начальной последовательности;</li>
<li>Увеличивает номер подтверждения получения;</li>
<li>Устанавливает поле ACK.</li>
</ul>
<p><strong>d. Данные передаются следующим образом:</strong></p>
<ul>
<li>Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.</li>
<li>Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она отправляет пакет ACK, в котором значение поля ACK равняется последней полученной последовательности.</li>
</ul>
<p><strong>e. Закрытие соединения:</strong></p>
<ul>
<li>Сторона, которая хочет закрыть соединение, отправляет пакет FIN;</li>
<li>Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;</li>
<li>Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.</li>
</ul>
<h2><a class="header" href="#tcp-windowing" id="tcp-windowing">TCP Windowing</a></h2>
<p>Чтобы установить максимально возможную и надежную пропускную способность, отправитель и получатель устанавливает идеальный объем данных для отправки в каждом пакете, используя опцию / поле TCP Window. Получатель объявляет отправителю сколько данных он может получить в каждом пакете ACK, который соответствует свободное пространство буфера для сокета (SO_RCVBUF) и по умолчанию составляет 65535 байт.</p>
<p>Верхний предел отправителя является объявленным окном получателя. Отправитель не должен отправлять больше неиспользованных данных, чем это ограничение, иначе это приведет к переполнению буфера, в результате чего получатель отбросит дополнительные пакеты.</p>
<p>Окно перегрузки - это управление потоком, которое динамически настраивается на пропускную способность и надежность сети. Окно перегрузки запускает окно, в два раза превышающее максимальный размер сегмента. Он увеличивается механизмом медленного запуска TCP на каждом ACKed-пакете на 1. С этим алгоритмом окно перегрузки фактически удваивается для каждого времени прохождения туда-обратно.</p>
<p>По достижении порога медленного старта TCP переходит от использования алгоритма медленного старта к алгоритму предотвращения скопления. Окно увеличивается на 1 сегмент за каждое путешествие туда и обратно.</p>
<h1><a class="header" href="#Балансировщик-нагрузки" id="Балансировщик-нагрузки">Балансировщик нагрузки</a></h1>
<p>Поскольку многие люди могут пытаться получить доступ к одной и той же веб-странице в одно и то же время, для обслуживания веб-страницы используется несколько серверов, поэтому для распределения трафика между серверами используется балансировщик нагрузки.</p>
<p>Ниже приведены преимущества использования балансировщика нагрузки:</p>
<ul>
<li>Уменьшена нагрузка на отдельный сервер.</li>
<li>Больший объем работы, выполненный в одно и то же время за счет параллелизма.</li>
<li>Увеличение производительности веб-страницы/приложения из-за более быстрого отклика.</li>
<li>Нет единой точки отказа. В среде с балансировкой нагрузки, если происходит сбой сервера, веб-страница/приложение все еще работает и обслуживается другими серверами в кластере.</li>
<li>Когда используется соответствующий алгоритм балансировки нагрузки, он обеспечивает оптимальное и эффективное использование ресурсов, поскольку исключает сценарий использования ресурсов одних серверов, чем других.</li>
<li>Масштабируемость: мы можем увеличивать или уменьшать количество серверов на лету, не отключая приложение.</li>
<li>Балансировка нагрузки повышает надежность веб-страницы/приложения</li>
<li>Повышенная безопасность, поскольку физические серверы и IP-адреса являются абстрактными в определенных случаях.</li>
</ul>
<h1><a class="header" href="#tls-handshake" id="tls-handshake">TLS handshake</a></h1>
<ul>
<li>Клиентский компьютер отправляет сообщение ClientHello серверу со своей версией протокола TLS, списком поддерживаемых алгоритмов шифрования и методов компрессии данных.</li>
<li>Сервер отвечает клиенту сообщением ServerHello, содержащим версию TLS, выбранный метод шифрования, выбранные методы компрессии и публичный сертификат сервиса, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использоваться клиентом для шифрования оставшейся части процедуры «рукопожатия» (handshake), пока не будет согласован симметричный ключ.</li>
<li>Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять, и клиент генерирует строку псевдослучайных байтов и шифрует её с помощью публичного ключа сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.</li>
<li>Сервер расшифровывает случайные байты с помощью своего секретного ключа и использует эти байты для генерации своей копии симметричного мастер-ключа.</li>
<li>Клиент отправляет серверу сообщение Finished, шифруя хеш передачи с помощью симметричного ключа.</li>
<li>Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хеш, чтобы проверить, совпадёт ли он с собственным. Если совпадение обнаружено, сервер отправляет клиенту собственный ответ Finished, также зашифрованный симметричным ключом.</li>
<li>После этого TLS-сессия передаёт данные приложения (HTTP), зашифрованные с помощью подтверждённого симметричного ключа.</li>
</ul>
<h1><a class="header" href="#Протокол-http" id="Протокол-http">Протокол HTTP</a></h1>
<p>Если используемый браузер был создан Google, то вместо отправки HTTP-запроса для получения страницы, он отправит запрос, чтобы попытаться «договориться» с сервером об «апгрейде» протокола с HTTP до SPDY («спиди»).</p>
<p>Если клиент использует HTTP-протокол и не поддерживает SPDY, то отправляет серверу запрос следующей формы:</p>
<pre><code class="language-ini">GET / HTTP/1.1
Host: google.com
Connection: close
[другие заголовки]
</code></pre>
<p>где [другие заголовки] — это серия пар «ключ: значение», разбитых переносом строки. (Здесь предполагается, что в использованном браузере нет никаких ошибок, нарушающих спецификацию HTTP. Также предполагается, что браузер использует HTTP/1.1, в противном случае он может не включать заголовок Host в запрос и версия, отданная в ответ на GET-запрос может быть HTTP/1.0 или HTTP/0.9).</p>
<p>HTTP/1.1 определяет опцию закрытия соединения («close») для отправителя — с её помощью происходит уведомление о закрытии соединения после завершения ответа. К примеру:</p>
<pre><code class="language-ini">Connection: close
</code></pre>
<p>Приложения HTTP/1.1, которые не поддерживают постоянные соединения, обязаны включать опцию «close» в каждое сообщение.</p>
<p>После отправки запроса и заголовков, браузер отправляет серверу единичную пустую строку, сигнализируя о том, что содержимое сообщения закончилось.</p>
<p>Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей формы:</p>
<pre><code class="language-ini">200 OK
[заголовки ответа]
</code></pre>
<p>После этого посылается пустая строка, а затем оставшийся контент HTML-страницы www.google.com. Сервер может затем закрыть соединение, или, если того требуют отправленные клиентом заголовки, сохранять соединение открытым для его использования следующими запросами.</p>
<p>Если HTTP-заголовки отправленные веб-браузером включают информацию, которой серверу достаточно для определения версии файла, закэшированного в браузере и этот файл не менялся со времени последнего запроса, то ответ может принять следующую форму:</p>
<pre><code class="language-ini">304 Not Modified
[заголовки ответа]
</code></pre>
<p>и, соответственно, клиенту не посылается никакого контента, вместо этого браузер «достаёт» HTML из кэша.</p>
<p>После разбора HTML, браузер (и сервер) повторяет процесс загрузки для каждого ресурса (изображения, стили, скрипты, favicon.ico и так далее), на который ссылается HTML-страница, но при этом изменяется адрес каждого запроса c GET / HTTP/1.1 на GET /$(относительный URL ресурса www.google.com) HTTP/1.1.</p>
<p>Если HTML ссылается на ресурс, размещённый на домене, отличном от google.com, то браузер возвращается к шагам, включающим разрешение доменного имени, а затем заново проходит процесс до текущего состояния, но уже для другого домена. Заголовок Host в запросе вместо google.com будет установлен на нужное доменное имя.</p>
<h2><a class="header" href="#Методы-http-запросов" id="Методы-http-запросов">Методы HTTP-запросов</a></h2>
<p>Спецификация HTTP определяет ряд «методов» или действий, которые пользователь может выполнить на конкретном ресурсе.</p>
<p>Наиболее распространенным является «GET», который также используется почти все время, когда пользователь вводит URL-адрес в адресную строку своего браузера или щелкает гиперссылку. Этот метод представляет загрузку данных с сервера, не затрагивая их (хотя сервер может изменить сам ответ на запросы GET, если понадобится).</p>
<p>Следующим наиболее популярным методом является «POST», который обычно используется, когда пользователь нажимает кнопку «Отправить» после ввода текста в формы или выбора файла на своем компьютере. Этот метод представляет добавление нового контента на страницу, уже сохраненную на сервере.</p>
<p>Другие методы включают «PUT» и «DELETE», которые добавляют и удаляют целые ресурсы; «PATCH», который изменяет существующий ресурс; и «CONNECT», который используется, когда браузер сообщает прокси-серверу HTTP, что нужно пересылать запросы пользователя, а не делать запросы напрямую.</p>
<h2><a class="header" href="#Обработка-http-запросов-на-сервере" id="Обработка-http-запросов-на-сервере">Обработка HTTP-запросов на сервере</a></h2>
<p>HTTPD (HTTP Daemon) является одним из инструментов обработки запросов/ответов на стороне сервера. Наиболее популярные HTTPD-серверы это Apache или Nginx для Linux и IIS для Windows.</p>
<ul>
<li>
<p>HTTPD (HTTP Daemon) получает запрос.</p>
</li>
<li>
<p>Сервер разбирает запрос по следующим параметрам:</p>
<ul>
<li>Метод HTTP-запроса (GET, HEAD, POST, PUT, PATCH, DELETE, CONNECT, OPTIONS или TRACE). В случае URL-адреса, который пользователь напечатал в строке браузера, мы имеем дело с GET-запросом.</li>
<li>Домен. В нашем случае — google.com.</li>
<li>Запрашиваемые пути/страницы, в нашем случае — / (нет запрошенных путей, / — это путь по умолчанию).</li>
</ul>
</li>
<li>
<p>Сервер проверяет существование виртуального хоста, который соответствует google.com.</p>
</li>
<li>
<p>Сервер проверяет, что google.com может принимать GET-запросы.</p>
</li>
<li>
<p>Сервер проверяет, имеет ли клиент право использовать этот метод (на основе IP-адреса, аутентификации и прочее).</p>
</li>
<li>
<p>Если на сервере установлен модуль перезаписи (mod_rewrite для Apache или URL Rewrite для IIS), то он сопоставляет запрос с одним из сконфигурированных правил. Если находится совпадающее правило, то сервер использует его, чтобы переписать запрос.</p>
</li>
<li>
<p>Сервер находит контент, который соответствует запросу, в нашем случае он изучит индексный файл.</p>
</li>
<li>
<p>Далее сервер разбирает («парсит») файл с помощью обработчика. Если Google работает на PHP, то сервер использует PHP для интерпретации индексного файла и направляет результат клиенту.</p>
</li>
</ul>
<h1><a class="header" href="#Вольный-перевод-части-репы-1" id="Вольный-перевод-части-репы-1">Вольный перевод части репы</a></h1>
<p>What happens when ... Kubernetes edition! <a href="https://github.com/jamiehannaford/what-happens-when-k8s">https://github.com/jamiehannaford/what-happens-when-k8s</a></p>
<p>Часть перевода взял с <a href="https://habr.com/ru/company/flant/blog/342658/">https://habr.com/ru/company/flant/blog/342658/</a></p>
<p>Представим, что я хочу задеплоить nginx в кластере Kubernetes. Я введу в терминале нечто такое:</p>
<p>kubectl run --image=nginx --replicas=3
… и нажму на Enter. Через несколько секунд увижу 3 пода с nginx, распределённые по всем рабочим узлам. Работает — словно по волшебству, и это здорово! Но что на самом деле происходит под капотом?</p>
<p>Одно из замечательных свойств Kubernetes — как эта система обслуживает развёртывание рабочих нагрузок в инфраструктуре через дружелюбные к пользователям API. Вся сложность скрыта простой абстракцией. Однако для того, чтобы полностью осознать ценность, которую приносит K8s, полезно понимать внутреннюю кухню. Тут будет описан весь жизненный цикл запроса от клиента до kubelet, при необходимости будут ссылки на исходный код для иллюстрации происходящего.</p>
<h1><a class="header" href="#Кратко" id="Кратко">Кратко</a></h1>
<h2><a class="header" href="#kubectl" id="kubectl">kubectl</a></h2>
<ul>
<li>Валидирует запрос — проверяет что он понимает что это за запрос.</li>
<li>Составляет http запрос к apiserver в соответствии с вычисленным типом ресурса — под, деплоймент и прочие разные штуки kube’а.</li>
<li>Договаривается с apiserver об используемой версии api.</li>
<li>Аутентифицируется в apiserver — по сертификатам, токену или паролю.</li>
</ul>
<h2><a class="header" href="#kube-apiserver" id="kube-apiserver">kube-apiserver</a></h2>
<ul>
<li>Аутентифицирует клиента разрешенными = указанными при старте способами.</li>
<li>Авторизует запрос ­ — что вам его можно выполнять. По цепочке авторизаторов — по файлам политик и проч.</li>
<li>Контроль допуска — проверяет что вообще такого типа запросы на этом кластере разрешены — лимиты, квоты и т.п.</li>
<li>Формирует соответствующий запросу ресурс — runtime представления заказанного пода, деплоймента и т.п.</li>
<li>Сохраняет его в etcd через “поставщик хранилища”, но в неинициализированном виде — не ставится галка.</li>
<li>Поставщик хранилища его сохраняет и get’ает, чтобы проверить успешное сохранение.</li>
<li>Apiserver отправляет http ответ.</li>
<li>Поставщик хранилища вызывает post-hooks.</li>
</ul>
<h2><a class="header" href="#Инициализаторы" id="Инициализаторы">Инициализаторы</a></h2>
<p>Если у вновь записанного типа ресурса есть какие-то предварительные шаги, то на его создание зарегистрированы соответствующие инициалайзеры, как например, ижектеры проксей для пода и т.п.</p>
<ul>
<li>Эти инициализаторы записываются в pending список этому ресурсу.</li>
<li>И начиная с первого выполняются по одному — они подписаны на объекты и если видят себя в голове списка, то отрабатывают.</li>
<li>Пустой список означает, что ресурс initialized. И он становится доступен контроллерам.</li>
</ul>
<h2><a class="header" href="#Контроллеры" id="Контроллеры">Контроллеры</a></h2>
<ul>
<li>Каждый из них считывает состояние каких-то etcd нод, за которые он отвечает. Например, Deployment controller видит, что появился новый деплоймент nginx’ов и его ответственность — создать нужные ReplicaSet’ы. Создать в смысле записать в etcd в нужном виде.</li>
<li>Когда записаны новые ReplicaSet’ы, то в свою очередь ReplicaSet controller видит, что его понимание о том какие поды существуют не соответствует тому какие ReplicaSet’ы указаны в etcd. И он начинает создавать нужные pod’ы согласно правилам, например, соблюдая ReplicaSet burst count — количество подов создаваемых за раз.</li>
<li>Контроллеры узнают об изменении в хранилище через Informer’ы — специальный механизм листенеров над etcd.</li>
</ul>
<h2><a class="header" href="#Шедулер" id="Шедулер">Шедулер</a></h2>
<ul>
<li>Когда все контроллеры отработали и завели все нужные поды, поды будут тем не менее находиться в Pending состоянии, т.к. они еще не были назначены на конкретные ноды.</li>
<li>Шедулер работает примерно так же как другие контроллеры — он слушает все события про поды и отфильтровывает поды, у которых NodeName пустой и пытается найти им подходящие Ноды.</li>
<li>Шедулинг происходит так:
<ul>
<li>Прежде всего проверяется цепочка предикатов, которые отфильтровывают неподходящие ноды. Например, если в PodSpec’е указаны CPU ресурс, а на какой-то ноде столько нет.</li>
<li>Дальше выполняются функции приоритета, по которым оставшиеся ноды ранжируются. Например, выше ставится нода с большим количеством свободных ресурсов.
Когда нода выбрана, шедулер создает Binding запрос к apiserver’у — который запишет имя ноды в NodeName PodSpec’и и установит PodScheduled статус в True .</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubelet" id="kubelet">kubelet</a></h2>
<ul>
<li>Это компонент запущенный на всех нодах Кубернетес кластера и занимающийся среди прочего жизненным циклом подов на этой ноде — он транслирует все необходимое из абстрации “Под” в реальные контейнеры, volum’ы и т.п.</li>
<li>kubelet так же как контроллеры и шедулер получает статус всех подов назначеных его ноде от apiserver’а и проверяет, что всё это соответсвует его локальной действительности.</li>
<li>А если что-то не соответствует, то он пытается отсинхронизовать действительность под желаемые аписервером требования. Вот что он делает:
<ul>
<li>Создает объект PodStatus, в котором отслеживается изменения его состояния, такие как Pending, Running, Succeeded, Failed. Например, определив какие контейнеры надо запустить, кублет понимает, что они еще не созданы, и поэтому Pod находится в Pending состоянии.</li>
<li>Затем этот PodStatus отдается статус-менеджеру Пода, который ассинхронно будет записывать обновления в apiserver.</li>
<li>Запускаются секьюрити хендлеры, которые, например, проверяют профили Apparmor. Поды не прошедшие эти хендлеры навсегда остаются в состоянии Pending.</li>
<li>Если был установлен флаг cgroups-per-qos, то kubelet создает cgroup’ы для пода и ставит туда ограничения ресурсов.</li>
<li>Кублет создает дата-директории для пода — /var/run/kubelet/pods/<podID> для самого пода, <podDir>/volumes для вольюмов и<podDir>/plugins для плагинов.</li>
<li>Volume manager будет ожидать соответствующих PodSpec’е вольюмов.</li>
<li>Кублет получит все соответвующие поду секреты от аписервера, чтобы позже их заинжектить в контейнер.</li>
<li>Container runtime запускает контейнер:</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#containerruntimeinterface" id="containerruntimeinterface">ContainerRuntimeInterface</a></h2>
<ul>
<li>CRI это абстракция между kubelet’ом и, например, docker’ом, которая нужна, чтобы кубернетес мог работать не только поверх docker’а, но и поверх rkt или вообще вирутальных машин.</li>
<li>kubelet запускает вызовRunPodSandbox, где “sandbox” это CRI термин обозначающий под. Т.е. это может быть как группа контейнеров, так и виртуалка или что-то подобное.</li>
<li>В случае docker’а создание sandbox’а соответствует созданию запаузенного (paused) контейнера — родительского контейнера для пода, через который все контейнеры пода будут шарить ресурсы — Linux неймспейсы (IPC, network, PID).</li>
</ul>
<h2><a class="header" href="#containernetworkinterface" id="containernetworkinterface">ContainerNetworkInterface</a></h2>
<ul>
<li>CNI это тоже интерфейс абстракция, которая позволяет подключать различные провайдеры организации сетей.</li>
<li>Если у Pod’а был сконфигурирован интерфейс типа bridge:
<ul>
<li>Плагин bridge создаст локальный линуксовый сетевой мост на ноде.</li>
<li>Затем вторая пара от veth будет заинжектена внутрь paused родительского контейнера, т.е. в его network namespace.</li>
<li>CNI присвоит этому интерфейсу IP и назначит роутинг. Делает это он через ipam (address manager) плагин, который, например, создает host-local конфигурацию.</li>
<li>CNI получив информацию о DNS сервере от kublet’а, пропишет ее в resolve.conf контейнеру.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Межнодовое-сетевое-взаимодействие" id="Межнодовое-сетевое-взаимодействие">Межнодовое сетевое взаимодействие</a></h2>
<p>Обычно оно организовывается с помощью overlay сети, например, это может быть layer-3 IPv4 межнодовая сеть, которая энкапсюлирует ip пакеты в UDP реальной сети.</p>
<h2><a class="header" href="#Запуск-контейнеров" id="Запуск-контейнеров">Запуск контейнеров</a></h2>
<p>После того как sandbox подготовлен, kubelet запускает уже реальные контейнеры Пода — сначала запускаются init контейнеры, если такие есть в спеке Пода, и только потом основные контейнеры.</p>
<ul>
<li>Pull’ится соответствующий образ.</li>
<li>CRI создает контейнер внутри родительского paused контейнера.</li>
<li>Если нужно, контейнер регистрируется в CPU manager’е — ему приписывается набор ЦПУ, на которых он будет работать.</li>
<li>Контейнера запускается!</li>
<li>Запускаются post-start хуки.</li>
</ul>
<h1><a class="header" href="#kubectl-1" id="kubectl-1">kubectl</a></h1>
<h2><a class="header" href="#Валидация-и-генераторы" id="Валидация-и-генераторы">Валидация и генераторы</a></h2>
<p>В первую очередь kubectl выполнит валидацию на стороне клиента. Он убедится, что нерабочие запросы (например, создание ресурса, который не поддерживается, или использование образа с неправильно указанным названием) быстро прервутся и не будут отправлены в kube-apiserver. Так улучшается производительность системы — благодаря снижению ненужной нагрузки.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-42238316-4', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
